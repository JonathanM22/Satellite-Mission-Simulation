"""
n-body. Trying to do n-body propagation
"""
from orbit import *
from Orbit_util import *
from body import *
import numpy as np
from scipy.integrate import solve_ivp
from scipy import optimize
import matplotlib.pyplot as plt

from astropy.time import Time
from astropy.time import TimeDelta
from astropy import units as u
from astropy import constants as const
from astropy.coordinates import solar_system_ephemeris
from astropy.coordinates import get_body_barycentric_posvel

def y_dot_n_ephemeris(t, y, central_body: Body, bodies: list[Body], step):
    """
        N-body propagation for sat, but the bodies are using ephemeris. 

        Direction matters! Look at notes for derivations. 

        r = distance from central body -> sat
        r_c = distance from origin -> central body
        r_k = distance from origin -> kth body
        r_sk = distance from sat -> kth body

        m_c = central body mass
        m_k = kth body mass
    """
    G = const.G.to(u.km**3 / (u.kg * u.s**2)).value
    y_dot = np.zeros(np.size(y))
    step = int(t / dt)
    print(step)

    # Get bodies ephemeris posvel
    r_c = central_body.r_ar[step-1,:]

    # Unpack sat state
    r = y[0:3]
    v = y[3:6]

    # Acceleration from central body
    r_mag = np.linalg.norm(r)
    m_c = central_body.mass.value
    a = ((G*m_c)/(r_mag**3)) * -r

    # Acceleration from kth bodies
    for body in bodies:
        r_k = body.r_ar[step-1,:]

        r_sk = (r_k - r_c) - r
        r_sk_mag = np.linalg.norm(r_sk)
        m_k = body.mass.value

        a += ((G*m_k)/(r_sk_mag**3)) * r_sk

    y_dot = np.concatenate([v, a])

    return y_dot

"""
#Constants and Intialization
"""
MOON_MASS = (7.34 * 10**22) * u.kg
MARS_MASS = (6.39 * 10**23) * u.kg
SAT_MASS = 100 * u.kg
G = const.G.to(u.km**3 / (u.kg * u.s**2))  # convert to km
SUN_MU = const.GM_sun.to(u.km**3 / u.s**2)
EARTH_MU = const.GM_earth.to(u.km**3 / u.s**2)
EARTH_RAD = const.R_earth.to(u.km)

# Intialize epoch, tof & arrivial date
solar_system_ephemeris.set('de432s')  # Ephemeris from 1950 - 2050
epoch = Time("2026-11-08")

# Intialize bodies
sun = Body(const.M_sun, epoch, celestial_body='sun', color="yellow")
earth = Body(const.M_earth, epoch, celestial_body="earth", color="green")
moon = Body(MOON_MASS, epoch, celestial_body="moon", color='grey')
mars = Body(MARS_MASS, epoch, celestial_body="mars", color="red")

SAT_MASS = 100*u.kg
sat = Spacecraft(SAT_MASS, epoch, label="S/C", color="purple")

earth_parking = Orbit(mu=EARTH_MU,
                      a=(32000*u.km + EARTH_RAD),
                      e=0.95*u.km/u.km,
                      f0=(180*u.deg).to(u.rad),
                      inc=(28*u.deg).to(u.rad),
                      raan=(174*u.deg).to(u.rad),
                      aop=(240*u.deg).to(u.rad)
                      )

earth_parking.p = earth_parking.calc_p()
earth_parking.energy = earth_parking.calc_energy()

transfer_short = Orbit(mu=const.GM_sun)

"""
Propagating the earth parking orbit
"""
tof = 180 * u.day
arrival_date = epoch + tof

# Defind Bodies for propagation 
central_body = earth
sat_orbit = earth_parking
bodies = [moon]

# Intiate Solver
dt = 3600 #sec
sat_orbit_period = (2*np.pi)*np.sqrt((sat_orbit.a**3)/sat_orbit.mu)
tspan = sat_orbit_period.value * 1.1
n_steps = int(np.ceil(tspan/dt))  
ys = np.zeros((n_steps, 6))
ts = np.zeros((n_steps, 1))

# Sat Intital Position
r = sat_orbit.r_at_true_anomaly(f=sat_orbit.f0)

r_pqw, v_pqw = orb_2_pqw(r.value,
                         sat_orbit.f0.value, sat_orbit.e.value,
                         sat_orbit.p.value, sat_orbit.mu.value) # Everything is in km, for numpy to work you need to have float numbers

r_eci, v_eci = perif_2_eci(r_pqw, v_pqw, sat_orbit.inc.value,
                           sat_orbit.raan.value, sat_orbit.aop.value)

sat.r0 = central_body.r0 + r_eci * u.km
sat.v0 = central_body.v0 + v_eci * (u.km/u.s)

y0 = np.concatenate((sat.r0.value, sat.v0.value))

# Need to define body arrays as numpy intially. 
sat.r_ar = np.zeros((n_steps, 3))
sat.v_ar = np.zeros((n_steps, 3))
central_body.r_ar = np.zeros((n_steps, 3))
central_body.v_ar = np.zeros((n_steps, 3))
for body in bodies:
    body.r_ar = np.zeros((n_steps, 3))
    body.v_ar = np.zeros((n_steps, 3))

# Initial Position of central body & bodies
central_body.r_ar[0,:] = central_body.r0.value
central_body.v_ar[0,:] = central_body.v0.value
for body in bodies:
    body.r_ar[0,:] = body.r0.value
    body.v_ar[0,:] = body.v0.value

# Run Solver
step = 1
solver = ode(y_dot_n_ephemeris)
solver.set_integrator('lsoda')
solver.set_initial_value(y0, 0)
ys[0] = y0
solver.set_f_params(central_body, bodies, step)
current_time = epoch

while solver.successful() and step < n_steps:
    
    # Integrate sat state
    solver.integrate(solver.t+dt)
    ts[step, :] = solver.t
    ys[step, :] = solver.y

    # Keep track of current time relative to epoch
    current_time += solver.t * u.s

    # Store celestial bodies posvel acording 2 ephemeris 
    cr, cv = get_body_barycentric_posvel(central_body.label, current_time)
    central_body.r_ar[step,:] = cr.xyz.to(u.km).value
    central_body.v_ar[step,:] = cv.xyz.to(u.km/u.s).value

    for body in bodies:
        br, bv = get_body_barycentric_posvel(body.label, current_time)
        body.r_ar[step,:] = br.xyz.to(u.km).value
        body.v_ar[step,:] = bv.xyz.to(u.km/u.s).value

    step += 1

# Store sat position as r_s wrt to barycenter
for step in range(n_steps):
    r = ys[step,0:3]
    v = ys[step,3:6]
    r_c = central_body.r_ar[step,:]
    v_c = central_body.v_ar[step,:]

    rs = r_c + r
    vs = v_c + v

    sat.r_ar[step,:] = rs
    sat.v_ar[step,:] = vs

"""
PLOT
"""

plot_bodies = [earth, moon, sat]
ax = plt.figure().add_subplot(projection='3d')


ax.plot(ys[:, 0], ys[:, 1], ys[:, 2], color=sat.color, label=sat.label)

#ax.plot(sat.r_ar[:, 0], sat.r_ar[:, 1], sat.r_ar[:, 2], color=sat.color, label=sat.label)

# formatting
ax.set_title(
    f"Earth–Mars Transfer Orbits {epoch.strftime('%Y-%m-%d')} - {arrival_date.strftime('%Y-%m-%d')}", fontsize=14, pad=10)
ax.set_aspect('equal')
plt.tight_layout()
ax.set_xlabel("X [m]")
ax.set_ylabel("Y [m]")
ax.set_zlabel("Z [m]")
ax.legend(loc='right')
ax.legend(loc='center left', bbox_to_anchor=(1.25, 0.5))

plt.show()

print("done")

"""
Plotting
"""
plot = False
if plot:
    """
    Plot trajectory 
    """
    ax = plt.figure().add_subplot(projection='3d')

    # Add Sun
    ax.scatter(0, 0, 0,
               color='yellow', s=15, marker='o', edgecolor='k', label="SUN")

    for body in bodies:

        """
        # Depature Point
        ax.scatter(body.r_ar[0, 0], body.r_ar[0, 1], body.r_ar[0, 2],  # type:ignore
                   color=body.color, s=15, marker='o', edgecolor='k', label=body.label)"""

        ax.plot(body.r_ar[:, 0], body.r_ar[:, 1], body.r_ar[:, 2],  # type:ignore
                color=body.color, label=body.label)

    # formatting
    ax.set_title(
        f"Earth–Mars Transfer Orbits {epoch.strftime('%Y-%m-%d')} - {arrival_date.strftime('%Y-%m-%d')}", fontsize=14, pad=10)
    ax.set_aspect('equal')
    plt.tight_layout()
    ax.set_xlabel("X [m]")
    ax.set_ylabel("Y [m]")
    ax.set_zlabel("Z [m]")
    ax.legend(loc='right')
    ax.legend(loc='center left', bbox_to_anchor=(1.25, 0.5))

    plt.show()

    """
    Plot Distance between S/C and Mars
    """
    dist_vec = sat.r_ar - mars.r_ar  # type:ignore
    dist_mag = np.linalg.norm(dist_vec, axis=1)

    # Plot distance vs time
    plt.figure()
    plt.plot(ts[:, 0] / 86400, dist_mag / 1e6)
    plt.xlabel("Time [days]")
    plt.ylabel("Distance between S/C and Mars [million km]")
    plt.title("Separation between Satellite and Mars over Time")
    plt.grid(True)
    plt.show()
